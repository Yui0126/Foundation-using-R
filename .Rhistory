for(i in 1:10)
i
i
print(i)
class(i)
x <- c("a","b","c","d")
for (i in 1:4) {
print(x[i])
}
}
for (i in seq_along(x)) {
print(x[1])
}
for (letter in x) {
print(letter)
}
for (b in 1:6) {
print(b^2)
}
for (j in 5) {
print(j**3)
}
aaa
for (k in 2:8)
for (k in 2:8) {}
for (k in 2:8) {
mean(k)
}
swirl()
library(swirl)
swirl()
TRUE == TRUE
FALSE == FALSE
(FALSE == TRUE) == FALSE
6 == 7
6 < 7
10 <= 10
5 != 7
5 == 7 !TRUE
5 !TRUE 7
5 != 7
!5 == 7
FALSE & FALSE
TRUE & c(TRUE,FALSE,FALSE)
TRUE && c(TRUE,FALSE,FALSE)
TRUE | c(TRUE,FALSE,FALSE)
TRUE || c(TRUE,FALSE,FALSE)
5 > 8 || 6 != 8 && 4 > 3.9
isTRUE(6 > 4)
identical('twins','twins')
xor(5 == 6, !FALSE)
ints <- sample(10)
ints
ints > 5
which(ints > 7)
any(ints < 0)
any(ints > 0)
all(ints > 0)
Sys.Date()
mean(c(2,4,5))
return(x)
x
submit()
boring_function()
boring_function(x)
boring_function(x)
boring_function(return(x))
return(boring_function(x))
boring_function <- function(x) {}
boring_function <- function(x) {}
boring_function <- function(x) {
x
}
submit()
boring_function <- function(x) {
x
}
submit()
boring_function <- function(x) {}
boring_function <- function(x) {
x
}
submit(boring_function())
submit(boring_function(x))
x
submit()
boring_function <- function(x) {
x
}
submit()
boring_function <- function(x) {
x
}
submit()
boring_function <- function(x) {
x
}
submit()
boring_function("My first function")
boring_function('My first function!')
boring_function()
function(boring_function())
boring_function
submit()
my_mean(c(4,5,10))
remainder <- function(num, divisor = 2) {
num %% divisor
}
submit()
remainder(5)
remainder(11,5)
remainder(divisor = 11, num = 5)
remainder(4, div = 2)
args(remainder)
submit()
evaluate(sd, c(1.4, 3.6, 7.9, 8.8))
evaluate(function(x){x+1}, 6)
evaluate(function(x){x,c(1)}, c(8, 4, 0))
evaluate(function(x){c(1)}, c(8, 4, 0))
evaluate(function(x){(1)}, c(8, 4, 0))
evaluate(function(x){x(1)}, c(8, 4, 0))
evaluate(function(x){x(c(1))}, c(8, 4, 0))
evaluate(function(x){x[1]}, c(8, 4, 0))
evaluate(function(x){x[3]}, c(8,4,0))
evaluate(function(x){length(x)}, c(8, 4, 0))
info()
evaluate(function(x){x[3]}, c(8, 4, 0))
evaluate(function(x){x[-1], c(8, 4, 0)})
evaluate(function(x){x[-1]}, c(8, 4, 0))
?paste
paste("Programming","is","fun!")
submit()
telegram
telegram("singing", "until","I","say")
submit()
mad_libs <- function(...){
args <- paste(..., place, ..., adjective, ..., noun, ...)
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
submit()
mad_libs <- function(...){
args <- paste(..., place, ..., adjective, ..., noun, ...)
args <- paste
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
submit()
submit()
submit()
mad_libs <- function(...){
args <- list(...)
place <- args[["place"]]
adjective <- args[["adjective"]]
noun <- args[["noun"]]
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
submit()
mad_libs <- function(...){
args <- list(...)
place <- args[["place"]]
adjective <- args[["adjective"]]
noun <- args[["noun"]]
paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
submit()
mad_libs(place = "Moon", adjective = "beautiful", noun = "Bob")
"%p%" <- function(left, right){
paste(left, right)
}
submit()
"I", "love" %p% "R"
"I""love" %p% "R"
"I love" %p% "R"
"I" %p% "love" %p% "R"
"I" %p% "love" %p% "R!"
library(swirl)
swirl()
d1 <- Sys.Date()
class(d1)
unclass(d1)
d1
d2 <- as.Date("1969-01-01")
unclass(d2)
t1 <- Sys.time()
t1
class(t1)
unclass(t1)
t2 <- as.POSIXlt(Sys.time())
t2
class(t2)
unclass(t2)
t2
unclass(t2)
str(unclass(t2))
t2$min
weekdays(d1)
months(t1)
quarters(t2)
t3 <- "October 17, 1986 08:24"
strptime(t3, "%B %d, %Y %H:%M")
t4 <- strptime(t3, "%B %d, %Y %H:%M")
t4
class(t4)
Sys.time() > t1
Sys.time() - t1
difftime(Sys.time(), t1, units = 'days')
pollutantmean("specdata", "sulfate", 1:10)
getwd()
setwd(C:/Users/ynaru/Desktop/R coursera/Data Science Foundations using R/Foundation using R/specdata)
setwd("C:/Users/ynaru/Desktop/R coursera/Data Science Foundations using R/Foundation using R/specdata")
getwd()
load("001")
load("001.csv")
load("specdata")
link.address.for.specdata.zip <- "https://d396qusza40orc.cloudfront.net/rprog%2Fdata%2Fspecdata.zip"
download.file(link.address.for.specdata.zip, "specdata20May2021.zip",
method = "wininet", quiet = FALSE, mode = "wb",
cacheOK = TRUE,extra = getOption("download.file.extra"),headers = NULL)
unzip("specdata20May2021.zip")
filenames <- list.files("specdata", full.names = TRUE)
filenames[2]
class(specdata)
filenames[3:5]
specdata <- read.csv(filenames[3:5])
specdata <- read.csv(filenames[3])
View(specdata)
tail(specdata)
mean(specdata$sulfate)
mean(specdata$sulfate, na.rm = T)
getwd()
getwd()
specdata <- getwd()
specdata
colnameToNumber <- function(colname){
# convert an Excel column name to the
# corresponding column number;
# should not depend on whether the
# letter(s) in colname are upper or
# lower case or a mixture of upper and
# lower case
# colname should be a character string such as "k" or "dz"
colname <- tolower(colname)
# so only need to deal with lower case
# arrange to treat column names from "a" up through "dz"
az <- letters  # c("a", ... , "z")
aaz <- paste("a", az, sep = "")
# c("aa", "ab", ... , "az")
# additional column names
baz <- paste("b", az, sep = "")
caz <- paste("c", az, sep = "")
daz <- paste("d", az, sep = "")
# concatenate the column names
colnames <- c(az, aaz, baz, caz, daz)
# get the number corresponding to the input column name
# using the which function
colnumber <- which(colnames == colname)
# test for having found a (unique) match
if(length(colnumber) != 1) stop("no match to colname")
return(colnumber)
}
colnameToNumber("a")
colnameToNumber("z")
colnameToNumber("aa")
colnameToNumber("az")
colnameToNumber("ba")
colnameToNumber("bz")
colnameToNumber("ca")
colnameToNumber("cz")
colnameToNumber("da")
colnameToNumber("dz")
# colnameToNumber("zz") # should get error message
?which
colnameToNumber("gz")
colnameToNumber("bc")
nu <- 22:55
which(nu[23])
which(nu, c(23))
nu %>%
which(24)
which(nu = 24)
which(nu == 24)
colnameToNumber("zc")
colvecToNumbers <- function(colvec){
# convert a character vector of Excel column names
# to the integer vector of corresponding column numbers
# each entry of colvec should be a column name between a and dz
# check the input is a non-empty character vector
# note a single character string is a character vector of length 1
if(length(colvec) < 1) stop("colvec input to colvecToNumbers is empty")
if(!is.character(colvec)) stop("colvec input to colvecToNumbers is not character")
# create the integer vector to be output
n <- length(colvec)
colnumbers <- integer(n)
# use colnameToNumber to get each entry of colnumbers
for (i in 1:n) {
colname <- colvec[i]
colnumbers[i] <- colnameToNumber(colname)
}
return(colnumbers)
}
colvec <- c("b", "g", "k", "q", "w") # the hospital data relevant columns
colvecToNumbers(colvec)
colvec <- c("b", "g", "k", "q", "w") # the hospital data relevant columns
colvecToNumbers(colvec)
colvec <- c("a", "aa", "ba", "ca", "da") # start of groups of 26 columns
colvecToNumbers(colvec)
colvec <- c("z", "az", "bz", "cz", "dz") # end of groups of 26 columns
colvecToNumbers(colvec)
